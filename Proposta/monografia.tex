% !TeX spellcheck = pt_BR
% ------------------------------------------------------------------------
% ------------------------------------------------------------------------
% abnTeX2: Modelo de Trabalho Academico (tese de doutorado, dissertacao de
% mestrado e trabalhos monograficos em geral) em conformidade com 
% ABNT NBR 14724:2011: Informacao e documentacao - Trabalhos academicos -
% Apresentacao
% ------------------------------------------------------------------------
% ------------------------------------------------------------------------

\documentclass[
    % -- opções da classe memoir --
    12pt,               % tamanho da fonte
    openright,          % capítulos começam em pág ímpar (insere página vazia caso preciso)
    oneside,
    %twoside,           % para impressão em recto e verso. Oposto a oneside
    a4paper,            % tamanho do papel. 
    % -- opções da classe abntex2 --
    %chapter=TITLE,     % títulos de capítulos convertidos em letras maiúsculas
    %section=TITLE,     % títulos de seções convertidos em letras maiúsculas
    %subsection=TITLE,  % títulos de subseções convertidos em letras maiúsculas
    %subsubsection=TITLE,% títulos de subsubseções convertidos em letras maiúsculas
    % -- opções do pacote babel --
    english,            % idioma adicional para hifenização
    french,             % idioma adicional para hifenização
    spanish,            % idioma adicional para hifenização
    brazil              % o último idioma é o principal do documento
    ]{abntex2}

% ---
% Pacotes básicos 
% ---
\usepackage[utf8]{inputenc}
\usepackage{lmodern}            % Usa a fonte Latin Modern          
\usepackage[T1]{fontenc}        % Selecao de codigos de fonte.

\usepackage{lastpage}           % Usado pela Ficha catalográfica
\usepackage{indentfirst}        % Indenta o primeiro parágrafo de cada seção.
\usepackage{color}              % Controle das cores
\usepackage{graphicx}           % Inclusão de gráficos
\usepackage{microtype}          % para melhorias de justificação
\usepackage{longtable}          % para tabelas longas
\usepackage{tabularx,ragged2e}
\usepackage{multirow}
\usepackage{algpseudocode,algorithm}    % para algoritmos       
\usepackage{pdfpages}
\usepackage{subfig}
\usepackage{hyperref}
\usepackage{amsmath}
%\usepackage{subcaption}
% ---
        
% ---
% Pacotes adicionais, usados apenas no âmbito do Modelo Canônico do abnteX2
% ---
\usepackage{lipsum}             % para geração de dummy text
% ---

% ---
% Pacotes de citações
% ---
\usepackage[brazilian,hyperpageref]{backref}     % Paginas com as citações na bibl
\usepackage[alf]{abntex2cite}   % Citações padrão ABNT


%Espaçamento em formulas e tabelas
\renewcommand{\arraystretch}{1.3}
\newcommand{\matlab}{MATLAB\textsuperscript{\textregistered}}


% --- 
% CONFIGURAÇÕES DE PACOTES
% --- 

% ---
% Configurações do pacote backref
% Usado sem a opção hyperpageref de backref
\renewcommand{\backrefpagesname}{Citado na(s) página(s):~}
% Texto padrão antes do número das páginas
\renewcommand{\backref}{}
% Define os textos da citação
\renewcommand*{\backrefalt}[4]{
    \ifcase #1 %
        Nenhuma citação no texto.%
    \or
        Citado na página #2.%
    \else
        Citado #1 vezes nas páginas #2.%
    \fi}%
% ---

% ---
% Informações de dados para CAPA e FOLHA DE ROSTO
% ---
\titulo{Avaliação quantitativa do método do gradiente conjugado precondicionado para a solução paralela e concorrente de um modelo de elementos finitos}
\autor{Thiago de Sousa Goveia}
\local{Timóteo}
\data{2017}
\orientador{Márcio Matias}
\instituicao{%
    Centro Federal de Educação Tecnológica de Minas Gerais
    \par
    Campus Timóteo
    \par
    Graduação em Engenharia de Computação
}
\tipotrabalho{Trabalho de conclusão de curso I (Graduação)}

% O preambulo deve conter o tipo do trabalho, o objetivo, 
% o nome da instituição e a área de concentração 
\preambulo{Proposta de trabalho apresentada como requisito das disciplinas trabalho de conclusão de curso I  e metodologia de pesquisa.}
% ---


% ---
% Configurações de aparência do PDF final

% alterando o aspecto da cor azul
\definecolor{blue}{RGB}{41,5,195}

% informações do PDF
\makeatletter
\hypersetup{
        %pagebackref=true,
        pdftitle={\@title}, 
        pdfauthor={\@author},
        pdfsubject={\imprimirpreambulo},
        pdfcreator={LaTeX with abnTeX2},
        pdfkeywords={abnt}{latex}{abntex}{abntex2}{trabalho acadêmico}, 
        colorlinks=true,            % false: boxed links; true: colored links
        linkcolor=blue,             % color of internal links
        citecolor=blue,             % color of links to bibliography
        filecolor=magenta,              % color of file links
        urlcolor=blue,
        bookmarksdepth=4
}
\makeatother
% --- 

% --- 
% Espaçamentos entre linhas e parágrafos 
% --- 

% O tamanho do parágrafo é dado por:
\setlength{\parindent}{1.3cm}

% Controle do espaçamento entre um parágrafo e outro:
\setlength{\parskip}{0.2cm}  % tente também \onelineskip

% ---
% compila o indice
% ---
\makeindex
% ---

% ----
% Início do documento
% ----
\begin{document}

% Seleciona o idioma do documento (conforme pacotes do babel)
%\selectlanguage{english}
\selectlanguage{brazil}

% Retira espaço extra obsoleto entre as frases.
\frenchspacing 

% ----------------------------------------------------------
% ELEMENTOS PRÉ-TEXTUAIS
% ----------------------------------------------------------
% \pretextual

% ---
% Capa
% ---
% \imprimircapa
% ---
% ---
% Folha de rosto
% (o * indica que haverá a ficha bibliográfica)
% ---
\imprimirfolhaderosto
% ---

% ---
% Inserir folha de aprovação
% ---

% Isto é um exemplo de Folha de aprovação, elemento obrigatório da NBR
% 14724/2011 (seção 4.2.1.3). Você pode utilizar este modelo até a aprovação
% do trabalho. Após isso, substitua todo o conteúdo deste arquivo por uma
% imagem da página assinada pela banca com o comando abaixo:
%
% \includepdf{folhadeaprovacao_final.pdf}
%
\iffalse
\begin{folhadeaprovacao}

  \begin{center}
    {\ABNTEXchapterfont\large\imprimirautor}

    \vspace*{\fill}\vspace*{\fill}
    \begin{center}
      \ABNTEXchapterfont\bfseries\Large\imprimirtitulo
    \end{center}
    \vspace*{\fill}
    
    \hspace{.45\textwidth}
    \begin{minipage}{.5\textwidth}
        \imprimirpreambulo
    \end{minipage}%
    \vspace*{\fill}
   \end{center}
        
   Trabalho aprovado. \imprimirlocal, 07 de abril de 2017:
   
   \assinatura{\textbf{Prof. \imprimirorientador} \\ Orientador} 
   \assinatura{\textbf{Prof. Marcelo de Sousa Balbino} \\ Coorientador}
   \assinatura{\textbf{Prof. Julio Cesar Onofre} \\ Professor Convidado}
   %\assinatura{\textbf{Professor} \\ Convidado 3}
   %\assinatura{\textbf{Professor} \\ Convidado 4}
      
   \begin{center}
    \vspace*{0.5cm}
    {\large\imprimirlocal}
    \par
    {\large\imprimirdata}
    \vspace*{1cm}
  \end{center}
  
\end{folhadeaprovacao}
\fi
%\includepdf{folhaaprovacao.pdf}
% ---

% ---
% Dedicatória
% ---
\iffalse
\begin{dedicatoria}
   \vspace*{\fill}
   \centering
   \noindent
   \textit{ Dedico esse trabalho à minha família, \\ fonte de motivação e educação.} \vspace*{\fill}
\end{dedicatoria}
\fi
% ---

% ---
% Agradecimentos
% ---
\iffalse
\begin{agradecimentos}
Agradecimentos...



\end{agradecimentos}
\fi
% ---

% ---
% Epígrafe
% ---
%\begin{epigrafe}
%    \vspace*{\fill}
%   \begin{flushright}
%       \textit{``Se os GAs são tão inteligentes,\\ por que eles não são ricos?''\\
%       (GOLDBERG, 1989, p.89)}
%   \end{flushright}
%\end{epigrafe}
% ---

% ---
% RESUMOS
% ---

% resumo em português
\setlength{\absparsep}{18pt} % ajusta o espaçamento dos parágrafos do resumo
\iffalse
\begin{resumo}
Resumo...

\textbf{Palavras-chave}: Palavras-chave...
\end{resumo}

% resumo em inglês
\begin{resumo}[Abstract]
 \begin{otherlanguage*}{english}
    Abstract...

   \vspace{\onelineskip}
 
   \noindent 
   \textbf{Keywords}: keywords...
 \end{otherlanguage*}
\end{resumo}
% ---

% ---
% inserir lista de ilustrações
% ---
\pdfbookmark[0]{\listfigurename}{lof}
\listoffigures*
\cleardoublepage
% ---

% ---
% inserir lista de tabelas
% ---
\pdfbookmark[0]{\listtablename}{lot}
\listoftables*
\cleardoublepage
% ---
\fi
% ---
% inserir o sumario
% ---
\pdfbookmark[0]{\contentsname}{toc}
\tableofcontents*
\cleardoublepage
% ---


% ----------------------------------------------------------
% ELEMENTOS TEXTUAIS
% ----------------------------------------------------------
\textual

% ----------------------------------------------------------
% Introdução (exemplo de capítulo sem numeração, mas presente no Sumário)
% ----------------------------------------------------------
\chapter{Introdução}
	Devido à popularização da computação de alto desempenho (HPC), trabalhos recentes têm retomado problemas tradicionais a fim de adequá-los aos novos paradigmas e arquiteturas de computação. De acordo com \citeonline{Kiss2012} a conformidade entre o problema a ser resolvido e a estrutura do ambiente de execução é capaz de ampliar a performance e reduzir a energia dispendida no processamento.
	Devido ao aumento da demanda por recursos computacionais, dispositivos que possibilitam a execução paralela acabaram se estabelecendo no mercado da informática.
	Por meio das arquiteturas \textit{manycore} e \textit{multicore}, é possível se executar paralela ou concorrentemente tanto tarefas corriqueiras como a exibição de vídeos e jogos até cálculos complexos da ciência e da engenharia.
	Podem ser citados como processadores \textit{multicore} as linhas Core e Xeon da Intel\nocite{intel}, Opteron e Ryzen da AMD\nocite{amd} e a linha Power da IBM\nocite{ibm}. Os dispositivos manycore por sua vez, têm como principais representantes as unidades de processamento gráfico (GPU) da qual fazem parte as placas GeForce, Quadro e Tesla da NVIDIA\nocite{nvidia} e Radeon e FirePro da AMD\nocite{amd}.
	
	O método dos elementos finitos (FEM) é um método numérico para a resolução de problemas de valor de contorno (PVC) modelados por equações diferenciais e também de problemas associados à minimização de um funcional de energia \cite{Szabo2009}. O algoritmo clássico do FEM foi concebido em sua forma sequencial e consiste principalmente na solução de um sistema linear esparso. A tarefa de se resolver tal sistema é geralmente custosa em termos de memória quando adotados métodos diretos como a eliminação gaussiana e computacionalmente custosa quando adotados métodos iterativos como o método de Jacobi.
	O método dos gradientes conjugados (CG) e suas variantes pertencem à família dos métodos exatos/iterativos do subespaço de Krylov \cite{Anzt2016} e tem sido adotados na literatura para a solução paralela de elementos finitos. Alguns trabalhos correlatos que utilizam a família CG são apresentados por \citeonline{Yao2015}, \citeonline{Ahamed2016} e \citeonline{Iwashita2017}.
	
	A fim de adequar o FEM às arquiteturas modernas será adotado neste trabalho a abordagem elemento a elemento (EbE-FEM) proposta por \citeonline{Hughes1983}. Esta técnica baseia-se no fato de que a matriz do sistema de elementos finitos é caracterizada como uma função parcialmente separável \cite{Dayde1995}, resultado da soma das matrizes elementares. Assim sendo, as operações da solução do sistema de elementos finitos podem ser realizadas em nível elementar, sem a necessidade de se montar a matriz global do sistema. Adicionalmente tem-se a vantagem de que elementos não adjacentes podem ser calculados simultaneamente por meio dos métodos CG \cite{Wathen1989}. Esta última característica torna a técnica EbE-FEM propícia para a implementação paralela nas arquiteturas modernas.
	
	
	

	
\section{Problema de Pesquisa}
	Neste trabalho é feita uma análise quantitativa do desempenho do algoritmo do EbE-FEM nas linguagens concorrentes C++, Erlang e Scala e nas linguagens de computação paralela, CUDA e Harlan.
	O problema \textit{benchmark} a ser resolvido refere-se à equação de Laplace originada do cálculo da distribuição de potencial e do campo elétrico de um capacitor de placas paralelas \cite[Exemplo 10.3]{boylestad2011}.
	A escolha deste problema se deve à simplicidade de sua modelagem e ao seu comportamento já explorado em livros de eletromagnetismo e circuitos elétricos.
	
	
\section{Justificativa}

A justificativa deste trabalho se baseia na contínua transformação dos paradigmas de programação e arquiteturas de hardware. Como coloca \citeonline{Guo2014}, com aumento de núcleos de processamento, ocorre a redução da razão memória por núcleo, o que impõe uma forte demanda para que os algoritmos utilizem eficientemente todos os níveis de paralelismo disponíveis enquanto minimizam a movimentação de dados. Tal evolução não se limita ao cenários dos \textit{clusters} e \textit{grids} mas alcança inclusive os dispositivos móveis, que atualmente já possuem até oito núcleos. Pensando em um futuro próximo, com os avanços da computação ubíqua que introduz temas como internet das coisas, dispositivos "usáveis", realidade aumentada e realidade virtual, a necessidade de se aproveitar ao máximo todo o poder de processamento disponível se torna ainda mais evidente, uma vez que nessas tecnologias há alta demanda de processamento e/ou pouco espaço físico para comportar um processador adequado. A justificativa para a escolha das linguagens C++, Scala e Erlang se dá devido à ausência de trabalhos acadêmicos relacionando tais tecnologias e seu desempenho. C/C++ é uma linguagem abrangente, robusta e atual, presente por trás de grande parte das aplicações \textit{desktop} e \textit{mobile}. Scala e Erlang (e/ou Elixir) são linguagens naturalmente concorrentes e que possuem crescente \textit{market share} \nocite{erlang}\nocite{scala}.


\section{Objetivos}

\subsection{Objetivos Gerais}

	\begin{itemize}
		\item Demonstrar o processo de mudança do paradigma sequencial para uma solução paralela do método do elementos finitos;
		\item Avaliar quantitativamente, segundo as métricas propostas (tempo de execução, uso de memória, e \textit{speedup}) o desempenho do processo de solução do EbE-FEM.
		\item Apresentar à comunidade resultados acadêmicos experimentais do desempenho das  linguagens C++, Scala, Erlang, CUDA e Harlan.
	\end{itemize}
		

\subsection{Objetivos Específicos}

	\begin{itemize}
		\item Investigar a viabilidade da técnica EbE-FEM como alternativa dos \textit{solvers} iterativos e do solver do  \matlab;
		\item Desenvolver um material acessível e de fácil compreensão de introdução ao FEM para o nível da graduação;
		\item Investigar o quão otimizada é a convergência do EbE a partir do emprego de diferentes precondicionadores;		
		\item Relacionar as métricas e conceitos de estatísticas necessários para a avaliação adequada de performance;
		\item Comparar conforme as métricas o desempenho das linguagens nativamente concorrentes e paralelas na resolução do problema \textit{benchmark} proposto neste trabalho.
	\end{itemize}

\section{Resultados Esperados}

Espera-se com este trabalho iniciar no CEFET-MG campus Timóteo uma nova linha de pesquisa a ser continuada nos trabalhos futuros, voltada para a análise numérica de problemas de valor de contorno da física aplicada. De forma similar, espera-se o incentivo e a adoção por parte da universidade de paradigmas e linguagens emergentes, a fim de diversificar o currículo dos graduandos.


\chapter{Revisão bibliográfica}
\section{Estado da arte}
Como coloca \citeonline{Kiss2012}, o processamento paralelo de um problema modelado pelo FEM pode ser feito a partir da decomposição do domínio do problema. Esta decomposição pode ser feita por meio do particionamento da malha que representa o domínio do problema ou por meio da decomposição apropriada da matriz de coeficientes.
Os trabalhos de \citeonline{Boehmer2011} e \citeonline{Ahamed2016} apresentam a solução paralela do FEM por meio do particionamento da malha. No primeiro caso o processamento é executado comparativamente nas arquiteturas de memória compartilhada e distribuída com o uso da API OpenMP e da biblioteca MPI respectivamente.
No segundo caso, a comparação é feita entre as linguagens CUDA e OpenCL que são executadas em uma arquitetura \textit{manycore}. 

A técnica EbE é uma forma de decomposição da matriz de coeficientes e será tratada neste trabalho. Por meio desta, as operações são realizadas na matriz de cada elemento, sem que seja necessária a montagem do sistema global. Esta estrutura de dados foi proposta originalmente por \citeonline{Hughes1983} como uma fatoração especial para a matriz de coeficientes de forma a melhorar sua condição a acelerar a convergência \cite{Carey1988}. Devido ao seu desempenho, precisão, economia de memória e à possibilidade de processamento paralelo \cite{Levit1987, Jing2008, Kiss2012} a adoção da abordagem EbE tem sido recorrente à medida em que surgem novas tecnologias de HPC. 

\citeonline{Carey1988} apresenta uma implementação EbE do gradiente biconjugado (BiCG) para solucionar um sistema de elementos finitos (FE). Segundo ele, o surgimento de novas arquiteturas tais como os processadores vetoriais, paralelos e estações de trabalho microprocessadas foram responsáveis por se repensar o algoritmo original do FEM. A execução vetorial foi realizada no computador CRAY-XMP e foi $8$ vezes mais rápida em relação ao processamento sequencial e apresentou \textit{speed-up} variando de $4.25$ à $6.5$. A execução paralela foi feita no ALLIANT-FX/8, um mini supercomputador com $8$ CPUs. Foi adotado um esquema de ordenação de nós a fim de se evitar condições de corrida no acesso às variáveis globais. Com a utilização de todas as unidade de processamento, o \textit{speed-up} foi em torno de $7$ em relação ao uso de uma única CPU. 

O trabalho de \citeonline{Dayde1995} faz uma análise comparativa entre $5$ precondicionadores de nível elementar para o algoritmo do gradiente conjugado (CG), a saber: \textit{Element matrix factorization} (EMF), \textit{finite element preconditioner} (FEP), \textit{one-pass element-by-element preconditioner} (EbE), \textit{two-pass element-by-element preconditioner} (EbE2) e Gauss-Seidel \textit{element-by-element preconditioner} (GS-EBE). Como os autores colocam, uma vez que se têm problemas de larga escala mas parcialmente separáveis, torna-se necessário explorar diferentes alternativas a fim de se aproveitar as vantagens oferecidas pela estrutura do problema. A abordagem EbE se mostrou a melhor opção entre seus concorrentes. EMF e FEP requerem a montagem parcial do sistema, o que agrega maior custo de processamento. EBE2 e GS-EBE não apresentaram boas aproximações para elementos com pouca vizinhança. A fim de se realizar a paralelização, é sugerida a coloração da malha de forma que elementos vizinhos sejam processados sequencialmente.

Uma implementação EbE-CG em FPGA (Field Programmable Gate Array) é proposta por \citeonline{Jing2008}. Neste trabalho as operações sobre as matrizes elementares foram realizadas por meio da configuração de um circuito lógico no chip 4VLX160 da Xilinx. O processamento sequencial foi feito em um PC $2.01$ GHz Athlon $64$ com as devidas otimizações na compilação. Graças à implementação diretamente em hardware foi alcançado um \textit{speed-up} máximo igual a $40$.

O surgimento da linguagem CUDA em 2006 e a popularização das GPGPU possibilitaram que a técnica de EbE pudesse ser revisitada e aplicada nas arquiteturas modernas. \citeonline{Kiss2012} soluciona o um modelo de elementos finitos por meio do BiCG com precondicionador de Jacobi.  De acordo com este trabalho, a abordagem EbE é adequada para o processamento em GPU, cuja arquitetura embora seja massivamente paralela, possui um gargalo, que é a  capacidade limitada de memória. O caráter localizado do EbE faz com que o trânsito de dados seja mínimo, o que reduz o consumo de energia e maximiza o potencial do dispositivo. Para a realização dos testes foram utilizados o processador quad-core Xeon X3440 da Intel e a placa GTX 590 da NVIDIA, contendo $2$ GPUs. A execução com aceleração em GPU consumiu 20 vezes menos memória e foi 10 vezes mais rápida que a execução unicamente em CPU.

O trabalho de \citeonline{Wu2015} também apresenta o método BiCG elemento a elemento com precondicionador de Jacobi implementado em GPU. Foi utilizado o processador Xeon E5-2696v2 da Intel e a placa Tesla K20c da NVIDIA. Nos dois refinamentos de malha testados foi alcançado um \textit{speed-up} de $4.63$, e como coloca o autor, o resultado obtido se torna ainda mais efetivo à medida em que o número de elementos aumenta. No trabalho mais recente dos mesmos autores \cite{Yan2017} é apresentado o uso do precondicionador de Gauss-Seidel para a abordagem EbE, o qual apresentou melhores resultados para o número de iterações e tempo de execução em relação ao precondicionamento de Jacobi, mantendo a mesma precisão.

Outros trabalhos importantes para esta monografia são os de \citeonline{Xu2005}, \citeonline{Yao2015} e \citeonline{Chou2016}. O primeiro apresenta a implementação do EbE-CG e a técnica de atribuição das condições de contorno que também será empregada no presente trabalho. O segundo apresenta a comparação da performance da implementação do BiCG estabilizado (BiCGStab) em CPU e GPU, utilizando-se diferentes formas de armazenamento de matriz esparsa e diferentes ferramentas de resolução de sistema linear em GPU, a saber: CUSPARSE, CUSP e CULA Sparse. O último trabalho apresenta a comparação entre diferentes tecnologias de processamento paralelo (Cuda C, Cuda Fortran, MPI e OpenMP) na resolução de dois problemas \textit{benchmark}


\section{Fundamentação teórica}
% ---
Neste capítulo é apresentado o referencial teórico para a compreensão dos métodos e conceitos utilizados ao longo deste trabalho. 
Na \hyperref[sec:PVC]{primeira seção} é apresentada a definição de Problemas de Valor de Contorno (PVC) bem como o problema a ser solucionado neste trabalho. 
Na \hyperref[sec:SED]{seção seguinte}, são abordados os Sistemas de Elementos Discretos a fim de fornecer a compreensão intuitiva e genérica do Método dos Elementos Finitos.
Em seguida, na seção \ref{sec:FEM} é feita a introdução ao Método dos Elementos Finitos (FEM). 
As seções \ref{sec:preProc}, \ref{sec:proc} e \ref{sec:posProc} abordam respectivamente, as etapas de pré-processamento, análise e pós-processamento do FEM.
Nas seção \ref{sec:eletromag} são apresentadas as equações de Maxwell para o Eletromagnetismo e na seção \ref{sec:tecItera} são mostradas algumas técnicas iterativas para a resolução de sistemas lineares, tais como o Método do Gradiente Conjugado e o uso de Precondicionadores. Estas técnicas são as estratégias utilizadas para a realização da abordagem Elemento a Elemento (EbE) do FEM.
Por fim, a \hyperref[sec:GPGPU]{última seção} deste capítulo apresenta os principais fundamentos da programação de Uso Geral em Unidades de Processamento Gráfico (GPGPU).

\subsection{Problema de Valor de Contorno}
\label{sec:PVC}


Um problema de valor inicial PVI,pode ser definido como uma equação ou sistema de equações diferenciais no qual são dadas as condições iniciais do fenômeno. Tais condições são impostas sobre a variável dependente e suas derivadas em um único instante de tempo (inicial) $t_0$. Um problema de valor de contorno PVC por sua vez, apresenta tais condições impostas em pontos distintos, como por exemplo em $x_i$ e $x_f$. Geralmente os PVI são dados em função do tempo enquanto os PVC são dados em função do espaço \cite{boyceDiprima}.

Como pode ser visto na tabela \ref{tab:cond}. as condições estabelecidas sobre a variável dependente, são chamadas de \textit{condições de Dirichlet} ou \textit{essenciais}, enquanto as que são estabelecidas sobre as derivadas da variável dependente são  conhecidas como \textit{condições de Neumann} ou  \textit{naturais}. Além destas duas, existem as restrições específicas do fenômeno modelado, como por exemplo, condições de radiação ou de impedância para problemas do eletromagnetismo \cite{jin}. 


\begin{table}   
	\centering
	\begin{tabular}{|c|c|}  
		\hline
		\textbf{Condição} 
		& \textbf{Tipo} \\  
		\hline
		$u(x_i) = \alpha $ 
		& Dirichlet \\
		\hline
		$u(x_i) = 0$
		& Dirichlet Homogênea\  \\
		\hline
		$u'(x_i) = \beta$
		& Neumann \\
		\hline
		$u'(x_i) = 0$
		& Neumann Homogênea\  \\
		\hline
	\end{tabular}
	\caption{Exemplos de condições de contorno}
	\label{tab:cond}
\end{table}


A solução analítica de um PVC pode ser obtida por meio da integração direta ou a partir da aplicação de técnicas como a separação de variáveis, expansão em séries ou pela transformada de Laplace.
No entanto, a maioria dos problemas da engenharia e da ciência não são lineares e apresentam geometria ou condições de contorno complexas.  Estas características fazem com que a resolução analítica de tais problemas seja impraticável, sendo necessário recorrer a métodos numéricos para se obter uma solução aproximada \cite{boyceDiprima, powers}.



\subsection{Métodos numéricos para PVCs}
\label{sec:FEM}

O método dos elementos finitos (FEM) é uma alternativa numérica para a solução de PVCs.Neste método, o domínio do problema é visto como uma coleção de subdomínios, chamados de elementos finitos, sobre os quais, a equação que modela o problema é aproximada por um método variacional ou de resíduos ponderados \citeonline{reddy}. Essas diferentes vertentes do método surgiram graças aos esforços independentes de matemáticos, cientistas e engenheiros \cite{zien}. 

O método das diferenças finitas (FDM) assim como o FEM é uma abordagem numérica para a aproximação de PVCs. Este método consiste na discretização do domínio do problema por meio de uma grade de pontos e na aproximação de cada derivada da equação por um quociente-diferença adequado
\cite{burdenFaires}. Embora este método seja útil em muitos casos, se torna difícil aplicá-lo em problemas com geometria irregular ou com condições de contorno não usuais. Um exemplo pode ser visto na figura \ref{fig:mdfFem}.

Diferentemente do FDM, como coloca \citeonline{huebner}, o FEM divide o domínio não em pontos, mas em subdomínios, sobre os quais as equações são aproximadas por polinômios definidos por partes. O FEM também é capaz de representar mais fielmente o contorno (ou a borda) do problema. Desta forma, ele se apresenta como uma técnica mais poderosa e versátil para a modelagem de fenômenos com geometria complexa e meios não homogêneos \cite{sadiku}. 

\begin{figure}[!htb]
	\centering
	\includegraphics[scale=0.5]{figuras/fdm_fem.pdf}
	\caption{Método das diferenças Finitas e método dos Elementos Finitos}
	\label{fig:mdfFem}
\end{figure}

\subsection{Método dos Elementos Finitos}

O FEM surgiu originalmente como uma técnica de análise de deslocamentos e elasticidade de estruturas mecânicas, mas em seguida foi estendido para solucionar problemas de outros campos da física e da engenharia \cite{jin, desai, zien}.

As primeiras formulações do FEM são conhecidas como \textit{abordagem direta} ou \textit{formulação física}, que embora forneça a interpretação intuitiva do método, é util apenas para a resolução de problemas relativamente simples \cite{huebner, desai, zien}. O uso do princípio do trabalho virtual, para a determinação de forças na abordagem direta, levou à generalização do FEM, por meio da estratégia de minimização do funcional de energia. Esta técnica mais genérica  ficou conhecida como \textit{formulação variacional} \cite{desai, zien, jin} e tem como principal representante o método de Rayleigh-Ritz. Uma terceira abordagem, conhecida como \textit{Método dos Resíduos Ponderados} ou \textit{formulação generalizada} \cite{zien, huebner} é tradicionalmente utilizada e é ainda mais genérica que o princípio variacional, pois resolve diretamente as equações diferenciais do modelo, sem necessitar da existência de um funcional de energia \cite{desai}, ou ainda, sem exigir que o sistema seja positivo-definido. Neste trabalho será adotado o método dos resíduos ponderados, mais especificamente, o método de Galerkin.


\subsection{Método dos Resíduos Ponderados}
\label{sec:proc}

De acordo com \citeonline{jin}, a aplicação do FEM pode ser feita a partir de $4$ passos básicos, os quais serão detalhados nas subseções a seguir.


\subsubsection*{Discretização do Domínio} 
A discretização do domínio consiste na transformação do contínuo $\Omega$ em uma malha de elementos finitos (discretos). Cada elemento $\Omega_e$ dessa malha representa um subdomínio de $\Omega$.  
Nesta etapa são definidas a forma, a quantidade e o tamanho dos elementos, de forma que a representação em malha seja a mais próxima possível do objeto em análise \cite{desai}.

Conforme pode ser visto na figura \ref{fig:numeracao}, cada elemento é identificado na malha a partir de um número que lhe é atribuído. Os vértices (ou nós) de cada elemento também são numerados. Cada nó possui dois valores vinculados a ele, um atuando como identificador global (numeração do nó na malha) e o outro como identificador local (numeração dentro de um dado elemento). A numeração local é geralmente feita no sentido anti-horário, a fim de se obter um valor positivo no cálculo da área ou volume por meio do  determinante \cite{sadiku, jin}. 

Um fator que deve ser levado em consideração é o balanceamento entre o refinamento da malha e o esforço computacional necessário \cite{desai}. Como o valor da solução é aproximado para cada elemento, o excesso de elementos pode causar a propagação do erro de aproximação, levando a resultados indesejáveis.


\begin{figure}[!htb]
	\centering
	\includegraphics[scale=1.2]{figuras/id.pdf}
	\caption{Identificadores de elementos e nós}
	\label{fig:numeracao}
\end{figure}

\subsubsection*{Seleção das funções de interpolação}
\label{sec:interp}
O passo seguinte é a escolha das funções de interpolação (ou função de base ou de forma) \cite{huebner} que fornece uma aproximação da equação original dentro de cada subdomínio \cite{jin}. 
A função interpoladora escolhida geralmente é um polinômio, e isso ocorre por dois motivos a priori \cite{desai}:

\begin{itemize}  
	\item Facilidade de manipulação matemática, principalmente derivação e integração;
	\item Aproximação satisfatória quando truncado em uma ordem qualquer.
\end{itemize}

Na prática são escolhidos polinômios de primeira ou segunda ordem, mas ordens superiores podem ser adotadas para reduzir o erro de aproximação, sobretudo em bordas com curvaturas, no entanto, ocorre também o aumento da carga computacional \cite{jin}.

Seja a função $\phi$ desconhecida, da qual se deseja obter uma aproximação. A nível elementar, a função $\tilde{\phi^e}$ aproxima $\phi$ dentro do domínio do elemento $e$. O valor $\tilde{\phi^{e}_i}$  é a aproximação do valor de $\phi$ sobre o nó $i$ de $e$. Considerando um subdomínio bidimensional triangular, o valor aproximado em cada nó de um elemento é dado pela equação \ref{eq:interp}.

\begin{equation}
\label{eq:interp}
\tilde{\phi^e_i} = a^e + b^e x^e_i + c^e y^e_i
\end{equation}

Desta forma, a função que aproxima os valores dentro de todo o domínio $e$ é pode ser dada pela equação \ref{eq:interpol}.

\begin{equation}
\label{eq:interpol}
\tilde{\phi^e} = \sum_{j=1}^{n}{N_j^e (x, y) \phi_j^e} = 
\{N^e\}^T \{\phi^e\}
\end{equation}

Para manter esta aproximação em conformidade com os valores $\tilde{\phi^e_1}$, $\tilde{\phi^e_e}$ e $\tilde{\phi^e_3}$ em cada nó, a função $N_i^e$ deve ser escolhida de forma que seu comportamento seja o mesmo do delta de Kronecker, como mostra a equação \ref{eq:kron} a seguir.

\begin{equation}
\label{eq:kron}
N_i^e(x^e_j, y^e_j) = \delta_{ij} = \begin{cases}
1, \ i = j\\
0, \ i \neq j
\end{cases}
\end{equation}

As funções de interpolação mais comuns pertencem às famílias de funções Lagrange e Serendipity \cite{zien, volakis}.

\subsubsection*{Formulação do sistema de equações}
Na abordagem variacional destaca-se o método de Ritz, ou Rayleigh-Ritz, o qual tem por objetivo, minimizar o funcional variacional, ou funcional de energia, do problema aproximado \cite{volakis}. Embora tal abordagem tenha sido historicamente utilizada e possua fundamentação física e matemática, sua adoção, em muitos casos, é mais complicada em relação ao Método dos Resíduos Ponderados, pois demanda a formulação variacional do problema. Desta forma, se um problema é dado por um modelo diferencial, é necessário se obter a partir deste modelo a forma variacional equivalente, para só então se aplicar o método para a obtenção do sistema de equações. No eletromagnetismo, a formulação variacional das equações de Maxwell não é bem estabelecida \cite{jin}.

Para problemas que apresentam explicitamente condições de Dirichlet no contorno e cujo operador $\mathcal{L}$ é linear e auto-adjunto, é possível se obter imediatamente o funcional de energia correspondente \cite{zien}, no entanto, como mostra \cite[p. 29]{volakis}, para este tipo de operador a mesma integral da formulação variacional é obtida pelo método de Galerkin.


Seja a equação \ref{eq:operador}, uma equação de um PVC na qual $\mathcal{L}$ é um operador diferencial, $f$ é uma função de excitação conhecida e $\phi$ é a solução procurada.

\begin{equation}
\label{eq:operador}
\mathcal{L} \phi = f
\end{equation}

Se substituirmos a solução exata pela sua aproximação apresentada na equação \ref{eq:interpol}, um resíduo $r$ surge, como pode ser visto na equação \ref{eq:residuos}, em decorrencia dos erros de aproximação.

\begin{equation}
\label{eq:residuos}
r = \mathcal{L} \tilde{\phi} - f \neq 0
\end{equation}

Embora o resíduo em cada elemento seja diferente de zero em sua maioria, deseja-se que o resíduo total seja igual a zero. Para que isso seja possível, uma função de poderação $w_i$ é introduzida para cada subdomínio $e$. Desta forma na média dos $M$ subdomínios de $\Omega$ a condição residual é atendida \cite{volakis}.
As equações \ref{eq:res1} e \ref{eq:res2} correspondem ao sistema de resíduos ponderados. A ideia chave dessa abordagem é transformar o problema de valor de contorno para um sistema linear que forneça o valor aproximado. 

\begin{equation}
\label{eq:res1}
R_i^e = \int_{\Omega}{w_i^e r \ d\Omega} = 0 \qquad i = 1,2,3.
\end{equation}

\begin{equation}
\label{eq:res2}
R_i^e = \int_{\Omega}{w_i^e [\mathcal{L} \tilde{\phi} - f] \ d\Omega} = 0
\end{equation}  


A escolha particular de $w_i^e = N^e_i$ configura o método de Galerkin, o qual, para um operador $\mathcal{L}$ auto adjunto a matriz do sistema é simétrica e equivalente à matriz gerada pelo método de Ritz. Após a substituição da equação \ref{eq:interpol} em \ref{eq:res2} obtem-se a equação \ref{eq:galerkin}, a qual forma um sistema esparso de equações lineares como o apresentado em \ref{eq:sistema}.


\begin{equation}
\label{eq:galerkin}
R_i^e = \int_{\Omega}{N_i^e \mathcal{L} \{N\}^T \{\phi\} \ d\Omega\}} - \int_{\Omega}{N^e_i f \ d \Omega} = 0
\end{equation} 


\begin{equation}
\label{eq:sistema}
[K]\{\phi\} = {b}
\end{equation}  

É importante colocar que o parâmetro $w_i$ deve ser um conjunto de funções integraveis, linearmente independentes
\cite[p. 60]{reddy}. Alguns casos especiais do método dos resíduos ponderados são obtidos a partir da escolha de $w_i$:

\begin{equation}
\label{eq:metPond}
\begin{tabular}{ l l }
Método de Petrov-Galerkin & $ w_i = \psi_i \neq \phi_i $ \\ 
Método de Galerkin & $ w_i = \phi_i $\\  
Método dos Mínimos quadrados & $ w_i = \frac{d}{dx} \left(a(x)\frac{d \phi_i}{dx}\right) $ \\ 
Método da colocação & $ \delta(x - x_i)  $ 
\end{tabular}
\end{equation}


\subsubsection*{Método dos elementos finitos em 2 dimensões}
\label{sec:fem2d}

\subsection{Método dos gradientes conjugados}

\chapter{Desenvolvimento}

O desenvolvimento deste trabalho está  dividido nas etapas de \textit{validação do problema} e \textit{aplicação das estratégias}. Na primeira são apresentados os recursos utilizados para modelar o problema e para definir as possíveis estratégias de solução. De posse das informações obtidas nesta etapa, são definidos na etapa seguinte os métodos e as estruturas de dados adotados em cada linguagem de programação e arquitetura de processamento.

\section{Materiais e métodos}
O ambiente de desenvolvimento \matlab foi adotado para a realização da etapa de validação do problema. A motivação dessa escolha se deu pela facilidade da manipulação de matrizes oferecida pelo ambiente e pela existência de ferramentas dedicadas à especificação de PVCs e à programação paralela.
A aplicação das estratégias propostas na etapa de validação nas linguagens e arquiteturas adotadas neste trabalho é feita pela adequação da sintaxe e do paradigma de programação da implementação realizada no \matlab. 

\subsection{Especificação da geometria}
O problema \textit{benchmark} utilizado neste trabalho é o exemplo $10.3$ do livro Análise de Circuitos de \citeonline{boylestad2011} e é ilustrado na figura \ref{fig:mesh}{(a)}. O capacitor é composto de duas placas quadradas paralelas com lado de $2$ polegadas, cuja distância entre elas é de $\frac{1}{32}$ polegadas. O problema informa que a diferença de potencial entre as placas é de $48V$, dessa forma foi assumido que uma das placas possui $48V$ e e que a outra está aterrada.

A fim de se realizar uma análise mais ampla do problema a distribuição do campo elétrico será calculada entre as placas mas também no espaço ao redor. Será considerada uma região quadrada de $16cm$ de lado como mostra o esquema na figura \ref{fig:mesh}{(b)}. Também foi considerado que a espessura de cada placa é a metade da largura da região entre elas, ou seja, $\frac{1}{64}$ polegadas.


A fim de se obter um parâmetro da corretude dos resultados obtidos neste trabalho, foi feita a simulação do problema na \textit{partial differential equation toolbox} do \matlab. Por meio dessa ferramenta é possível programaticamente e via interface gráfica definir a equação diferencial que rege o problema, a geometria, as condições de contorno, a malha inicial e seus refinamentos bem como a solução e exibição dos resultados do PVC. As figuras \ref{fig:mesh}{(c)} e \ref{fig:mesh}{(d)} mostram a geometria e a malha inicial modeladas com o auxílio da interface gráfica da \textit{pdetool}.

\subsection{Obtenção dos valores de referência}


\begin{figure}%
	\centering
	\subfloat[Perspectiva do capacitor de placas paralelas]{{\includegraphics[scale=0.8]{figuras/placas.pdf} }}%
	\qquad	
	\subfloat[Esquema da região de análise]{{\includegraphics[scale=0.4]{figuras/espaco.pdf} }}%
	\qquad	
	\subfloat[Região de análise com malha]{{\includegraphics[scale=0.5]{figuras/mesh.pdf} }}%
	\qquad
	\subfloat[Zoom sobre as placas do capacitor]{{\includegraphics[scale=0.5]{figuras/meshzoom.pdf} }}%
	\caption{Geometria do capacitor de placas paralelas}%
	\label{fig:mesh}%
\end{figure}

Definidas a geometria e a malha, foram feitas as atribuições das condições de contorno de Dirichlet nas $4$ bordas da seção de cada placa. À placa da esquerda foram atribuídos $48V$ e $0V$ para a placa da direita. Para se definir a EDP do problema é necessário atribuir valores aos coeficientes da fórmula geral de EDPs elípticas, mostrada na equação \ref{eq:geral}.



\begin{equation}
\label{eq:geral}
- \bigtriangledown\cdot(c\bigtriangledown(u)) + au = f
\end{equation} 

Na equação de Laplace, que modela a distribuição do potencial elétrico, apenas o coeficiente $c$ é diferente de zero. A constante $c$ corresponde à permissividade no vácuo na equação de Poisson, mas como a densidade volumétrica de carga representada por $f$  e o auto valor $a$ são iguais a zero na equação de Laplace, $c$ passa a valer $1$. Estabelecidos os valores das constantes a solução do problema pode ser obtida, como mostram as figuras \ref{fig:solPde}{(a)} e \ref{fig:solPde}{(b)}.

\begin{figure}%
	\centering	
	\subfloat[Distribuição do potencial em Volts e fluxo do campo elétrico em Volts/centímetro (vetores normalizados)]{{\includegraphics[scale=0.4]{figuras/potcampo.pdf} }}%
	\qquad
	\subfloat[Distribuição do potencial entre as placas]{{\includegraphics[scale=0.4]{figuras/potzoom.pdf} }}%
	\qquad
	\subfloat[Pontos de referência do potencial elétrico]{{\includegraphics[scale=0.45]{figuras/valpot2.pdf} }}%
	\qquad
	\subfloat[Pontos de referência do campo elétrico]{{\includegraphics[scale=0.5]{figuras/valCampo.pdf} }}%
	\caption{Solução do PVC com a \textit{pdetool}}%
	\label{fig:solPde}%
\end{figure}

De posse da solução da \textit{pdetool}, foram tomados $8$ pontos de referência da distribuição do potencial e $3$ pontos de referência do campo elétrico. A localização e os valores destes pontos são apresentados na figuras \ref{fig:solPde}{(c)} e \ref{fig:solPde}{(d)}.

\subsection{Implementação do FEM}
Após a simulação e obtenção dos valores de referência foi realizada a implementação do método dos elementos finitos em duas dimensões, conforme o apresentado na seção \ref{sec:fem2d} do referencial teórico.
A fim de não tirar proveito das funções do \matlab de forma a manter a generalidade da solução implementada e a facilidade de transcrevê-la para outras linguagens, foram utilizadas nos algoritmos deste trabalho apenas as funções da \textit{PDE toolbox} relativas à geometria, geração da malha e exibição dos resultados. No pseudocódigo \ref{alg:FEM} as palavras destacadas em itálico são variáveis, as funções destacadas em negrito fazem parte do \matlab e as funções descritas nas linhas de $9$ a $12$ são detalhadas no exemplo da seção \ref{sec:fem2d}. A tabela \ref{tab:matlabFun} contém a descrição das funções utilizadas.

\begin{algorithm}	
	\caption{\label{alg:FEM}Pseudocódigo do FEM} 
	\begin{algorithmic}[1]
		\State{\textbf{load}($dadosGeometria$);}
		\State{\textbf{load}($coordReferencia$);}
		\State{\textbf{load}($dadosContorno$);}
		\State{$g$ = \textbf{decsg}($dadosGeometria$);}
		\State{$m$ = \textbf{createpde}(1);}
		\State{\textbf{geometryFromEdges}($m$,$g$);}
		\State{\textbf{generateMesh}($m$, 'Hmax',$valHmax$);}
		\State{($nos$,$tri$) = \textbf{meshToPet}($m.Mesh$);}
		\State{$C$ = geraMatElementares($nos$, $tri$);}
		\State{$G$ = geraMatGlobal($C$, $tri$);}
		\State{($A$, $b$) = atribuiContorno($G$, $dadosContorno$);}
		\State{$sol$ = resolveSistLinear($A$,$b$);}
		\State{\textbf{pdeplot}($m$,...);}
	\end{algorithmic}
\end{algorithm}


\begin{table}[!ht]   
	\centering
	\begin{tabular}{|l|p{10cm}|}  
		\hline
		\textbf{Função} 
		& \textbf{Descrição} 
		\\  
		\hline
		\textbf{load} 
		& Carrega para o \textit{workspace} as variáveis salvas nos arquivos \textit{.mat}. 
		\\
		\hline
		\textbf{decsg}  
		& Cria a geometria do problema por meio da associação de regiões primitivas. O espaço de análise do capacitor de placas paralelas, por exemplo é composto por $2$ retângulos e $1$ quadrado.
		\\
		\hline		
		\textbf{createpde} 
		& Instancia um modelo de PDE contendo $n$ equações.
		\\
		\hline		 
		\textbf{geometryFromEdges} 
		& Vincula a geometria originada da função $decsg$ ao modelo de PDE gerado por $createpde$.
		\\
		\hline		
		\textbf{generateMesh} 
		& Cria uma malha sobre a geometria do modelo de PDE. Parâmetros adicionais podem ser incluídos para modificar a qualidade malha ou a ordem dos elementos (ver \ref{sec:interp}). O parâmetro $Hmax$ determina o tamanho máximo das arestas dos elementos.
		\\
		\hline		 
		\textbf{meshToPet} 
		& Obtém as matrizes de pontos, arestas e triângulos, as quais serão utilizadas na geração das matrizes elementares e da matriz global.
		\\
		\hline	
		geraMatElementares
		& À partir dos dados da triangulação da malha, gera a matriz de cada elemento por meio das funções de aproximação e interpolação.
		\\
		\hline
		geraMatGlobal
		& Realiza a agregação ou o mapeamento das matrizes elementares no sistema global. A matriz resultante é esparsa e sua ordem corresponde ao número de nós da malha.
		\\
		\hline
		atribuiContorno  
		& Atribui os $m$ valores de contorno pré-estabelecidos e com isso realiza a redução dos sistema em $m$ ordens, fazendo com que deixe de ser homogêneo.
		\\
		\hline
		resolveSistLinear
		& Consiste na aplicação de métodos numéricos para a solução eficiente de sistemas lineares esparsos.
		\\
		\hline		 
		\textbf{pdePlot}  
		& Função utilizada para a exibição da malha e dos resultados. Conforme os parâmetros adicionais, são plotados gráficos tridimensionais, campos vetoriais e linhas de campo.
		\\
		\hline	
	\end{tabular}
	\caption{Descrição das funções utilizadas no algoritmo do FEM}
	\label{tab:matlabFun}
\end{table}
 


A função $resolveSistLinear$ é o ponto central deste trabalho, uma vez que a análise é feita sobre o desempenho das implementações na solução do sistema de equações originado do FEM. Foram utilizados $2$ \textit{solvers} a fim de se verificar a performance e a gestão de memória. O primeiro deles é o \textit{solver} ``$\setminus$'' do \matlab e o segundo é a implementação do método do gradiente conjugado proposta por \citeonline{Barrett1995}. O CG como explicitado no referencial teórico, é um método iterativo não estacionário do subespaço de Krylov. Como coloca \citeonline{Wathen1989}, o uso de métodos iterativos se tornou competitivo à medida em que os sistemas de equações se tornavam maiores. A técnica EBE foi proposta por \citeonline{Hughes1983} como como sendo um precondicionador para o CG de forma a possibilitar que as computações com matrizes sejam realizadas no nível elementar \cite{Kiss2012} de forma a possibilitar a vetorização (ou paralelização) e a economia de memória.

A motivação da escolha do \textit{solver} do \matlab (``$\setminus$'' ou $mldivide$) está no fato de ele utilizar diferentes algoritmos dependendo da estrutura da matriz de coeficientes, tais como simetria e esparsidade \cite{matMldivide}. Especificamente para o problema deste trabalho, cuja matriz é Hermitiana (auto-adjunta) e positiva definida, o \textit{solver} adota a fatoração de Cholesky ou a LDL.

A motivação para a escolha do CG implementado por \citeonline{Barrett1995} está no fato de que seu material é citado em diferentes trabalhos da revisão bibliográfica, como em \citeonline{Kiss2012, Dolwithayakul2012, Yang2016}. Além de um completo \textit{survey} de métodos numéricos para a solução de sistemas lineares, os autores disponibilizam as implementações na linguagem do \matlab e em C++. O pseudocódigo do CG precondicionado com a matriz $M$ é apresentado em \ref{alg:CG} e a descrição de cada etapa é apresentada na seção \ref{sec:CG} da fundamentação teórica.

\begin{algorithm}	
	\caption{\label{alg:CG}Pseudocódigo do CG} 
	\begin{algorithmic}[1]
		\State{$x_{0}$ = $\{0\}$}
		\State{$r_{0}$ = $b - Ax_0$}
		\For{i = 1,2...}
			\State{$z_{i-1}$ = resolve($M$, $r_{i-1}$)}
			\State{$\rho_{i-1}$ = ${r_{i-1}}^{T}z_{i-1}$}
			\If{i = 1}
				\State{$p_1$ = $z_0$}
				\Else
				\State{$\beta_{i-1}$ = $\rho_{i-1}$ / $\rho_{i-2}$}
				\State{$p_{i}$ = $z_{i-1}$ + $\beta_{i-1}p_{i-1}$}
			\EndIf	
			\State{$q_i$ = $Ap_i$}
			\State{$\alpha_{i}$ = $\rho_{i-1}$ / ${p_{i}}^Tq_i$}
			\State{$x_{i}$ = $x_{i-1}$ + $\alpha_{i}p_{i}$}
			\State{$r_{i}$ = $r_{i-1}$ - $\alpha_{i}q_{i}$}
			\If{converge($r$,$tol$)}
				\State{break}
			\EndIf
		\EndFor
	\end{algorithmic}
\end{algorithm}





\subsection{Implementação do EBE-FEM}
A implementação do EBE-FEM consiste basicamente em antecipar a solução do sistema de equações, passando da montagem das matrizes elementares diretamente para a atribuição das condições de contorno e solução do sistema, sem que seja necessária a montagem da matriz de coeficientes global. Para realizar esta mudança de rota na solução do problema é necessário modificar tanto o algoritmo quanto a estrutura de dados utilizados.

A adaptação do bloco referente à atribuição das condições de contorno (linha $11$ do algoritmo \ref{alg:FEM}) é baseada na abordagem proposta por  \citeonline{Xu2005} a qual consiste na criação de vetores \textit{rhs} (\textit{right hand side}) elementares. Ao invés de se atribuir os valores de contorno às células do vetor \textit{rhs} global que correspondem à cada nó da malha, a atribuição é feita no nível elementar. Por exemplo, se um nó compartilhado por $2$ elementos possui valor de contorno igual a $10$, a atribuição é feita como uma média no vetor \textit{rhs} de cada um dos $2$ elementos. Assim sendo, cada vetor recebe o valor de contorno igual a $5$. A figura \ref{fig:contornoEBE} contém o esquema que ilustra este exemplo. \citeonline{Yan2017} e \citeonline{Wu2015} propõe uma abordagem parecida baseada não no número de conexões do nó, mas na média ponderada do valor de contorno original pelos coeficientes de cada elemento que contém o nó. 

\begin{figure}[!htb]
	\centering
	\includegraphics[scale=0.8]{figuras/contorno.pdf}
	\caption{Esquema da aplicação das condições de contorno de um elemento}
	\label{fig:contornoEBE}
\end{figure}

De posse das matrizes e vetores elementares com as condições de contorno atribuídas, é feita a adaptação no algoritmo do  CG a fim de que os cálculos envolvendo matrizes sejam feitos elemento a elemento. As operações entre vetores e escalares são mantidas no nível global, visto que não requerem tanto esforço computacional como as operações matriciais.  As adaptações consistem basicamente em percorrer os $N$ elementos, realizando os cálculos pertinentes e em seguida, armazenar nos vetores globais os resultados gerados para cada nó do elemento. As linhas $4$ e $12$ do algoritmo \ref{alg:CG} possuem operações matriciais e são modificadas conforme apresentado nos pseudocódigos \ref{alg:ebeCG1} e \ref{alg:ebeCG2}. Além disso, o resíduo inicial da linha $2$ do \ref{alg:CG} é igual a $b$ , dado que o chute $x_0$ vale zero para todos os nós. Como os valores de $b$ foram atribuídos pelas condições de contorno em nível elementar, é necessário realizar a montagem do vetor $b$ global para a determinação do resíduo inicial aconteça. Este processo de montagem é apresentado no pseudocódigo \ref{alg:ebeCG3}.

\begin{algorithm}	
	\caption{\label{alg:ebeCG1}Adaptação da declaração $z_{i-1}$ = resolve($M$, $r_{i-1}$)} 
	\begin{algorithmic}[1]
		\State{$z$ = $\{0\}$}		
		\For{j = 1,2...$|tri|$}
		\State{$map = tri(j)$}
		\State{$M_e = precond(A_e(j))$}
		\State{$z(map) = z(map) + M_er(map)$}
		\EndFor
	\end{algorithmic}
\end{algorithm}

\begin{algorithm}	
	\caption{\label{alg:ebeCG2}Adaptação da declaração $q_i$ = $Ap_i$} 
	\begin{algorithmic}[1]
		\State{$q$ = $\{0\}$}		
		\For{j = 1,2...$|tri|$}
		\State{$map = tri(j)$}
		\State{$q(map) = q(map) + A_e(j)q(map)$}
		\EndFor
	\end{algorithmic}
\end{algorithm}

\begin{algorithm}	
	\caption{\label{alg:ebeCG3}Adaptação da declaração $r_{0}$ = $b - Ax_{0}$} 
	\begin{algorithmic}[1]
		\State{$b$ = $\{0\}$}		
		\For{j = 1,2...$|tri|$}
		\State{$map = tri(j)$}
		\State{$b(map) = b(map) + b_e(j)$}
		\EndFor
		\State{$r_{0}$ = $b$}
	\end{algorithmic}
\end{algorithm}

\subsection{Coloração da malha}
Proposta por \citeonline{Wathen1989} e implementada por \citeonline{Kiss2012} a coloração da malha possibilita que os trechos do CG descritos nos algoritmos \ref{alg:ebeCG1}, \ref{alg:ebeCG2} e \ref{alg:ebeCG3} sejam paralelizados. A coloração assim como o processo de exclusão mútua são estratégias adotadas para evitar condições de corrida. Condição de corrida é o estado inconsistente dos dados causado por transações não atômicas. Desta forma, se por exemplo, dois processos ou \textit{threads} alteram ao mesmo tempo um dado em memória compartilhada, não se pode prever o valor final do dado, mas sabe-se que será inconsistente. A coloração deve acontecer de tal forma que elementos que compartilhem um mesmo nó possuam cores distintas. Uma característica desejável num algoritmo otimizado é que haja uma distribuição equalizada na quantidade elementos de cada cor, ao invés de uma quantidade mínima de cores. Por exemplo, numa malha de $1000$ elementos é preferível se utilizar $20$ cores com $50$ elementos de cada cor, ao invés de $6$ cores com uma distribuição desequilibrada de elementos, como por exemplo $\{500 \ 50 \ 200 \ 150 \ 10 \ 90\}$. Contudo, como o objetivo da etapa de \textit{validação do problema} não é obter resultados ótimos, foi adotada uma heurística gulosa sem balanceamento de cores, mas que apenas prioriza a aplicação das cores menos utilizadas. A figura \ref{fig:color} mostra um zoom na coloração da malha no topo entre as duas placas.

\begin{figure}[!htb]
	\centering
	\includegraphics[scale=0.5]{figuras/color.pdf}
	\caption{Exemplo de coloração da malha}
	\label{fig:color}
\end{figure}

Uma vez realizada a coloração, o processamento pode ocorrer de tal forma que elementos da mesma cor seja executados simultaneamente e elementos de cores distintas sequencialmente. Como elementos de uma determinada cor não possuem vértices em comum, não há a possibilidade de acontecer condição de corrida durante o acesso às variáveis globais $z$ e  $r$ do algoritmo \ref{alg:ebeCorCG1} e $q$ e $d$ dos algoritmos \ref{alg:ebeCorCG2} e \ref{alg:ebeCorCG3} respectivamente. A estrutura de dados $cores$ contém os dados da localização do elemento na malha.

\begin{algorithm}	
	\caption{\label{alg:ebeCorCG1}Aplicação da coloração no algoritmo \ref{alg:ebeCG1}} 
	\begin{algorithmic}[1]
		\State{$z$ = $\{0\}$}
		\For{c = 1,2...$|cores|$}	
		\State{$triCor = cores(c)$}	
		\For{j = 1,2...$|triCor|$}
		\State{$idG = triCor(j)$}
		\State{$map = tri(idG)$}
		\State{$M_e = precond(A_e(idG))$}
		\State{$z(map) = z(map) + M_er(map)$}
		\EndFor
		\EndFor
	\end{algorithmic}
\end{algorithm}

\begin{algorithm}	
	\caption{\label{alg:ebeCorCG2}Aplicação da coloração no algoritmo \ref{alg:ebeCG2}} 
	\begin{algorithmic}[1]
		\State{$q$ = $\{0\}$}
		\For{c = 1,2...$|cores|$}	
		\State{$triCor = cores(c)$}					
		\For{j = 1,2...$|triCor|$}
		\State{$idG = triCor(j)$}
		\State{$map = tri(id)$}
		\State{$q(map) = q(map) + A_e(idG)q(map)$}
		\EndFor
		\EndFor
	\end{algorithmic}
\end{algorithm}

\begin{algorithm}	
	\caption{\label{alg:ebeCorCG3}Aplicação da coloração no algoritmo \ref{alg:ebeCG3}} 
	\begin{algorithmic}[1]
		\State{$b$ = $\{0\}$}
		\For{c = 1,2...$|cores|$}	
		\State{$triCor = cores(c)$}					
		\For{j = 1,2...$|triCor|$}
		\State{$idG = triCor(j)$}
		\State{$map = tri(idG)$}
		\State{$b(map) = b(map) + b_e(idG)$}
		\EndFor
		\EndFor
		\State{$r_{0}$ = $b$}
	\end{algorithmic}
\end{algorithm}

\subsection{Paralelização do algoritmo}
A fim de manter a conformidade com o ambiente de desenvolvimento optou-se por utilizar a \textit{parallel Computing toolbox} do \matlab. Esta ferramenta possibilita a implementação para plataformas \textit{multicore}, GPUs, \textit{clusters}, \textit{grids} e \textit{cloud}. De acordo com a documentação do \matlab \cite{matMulticore}, funções de álgebra linear como $fft$, $mldivide$, $eig$, $svd$, e $sort$
são \textit{multithread} desde a versão R2018a. No entanto, é possível melhorar a performance de funções customizadas por meio da \textit{parallel toolbox}.

A fim de garantir a robustez do código paralelizado, o \matlab disponibiliza a programação em múltiplos \textit{workers} ao invés de \textit{threads}. Cada \textit{worker} é um processo que trabalha em função do processo principal (\textit{client}) que o originou. Desta forma, as tarefas são divididas entre os \textit{workers} e coordenadas pelo \textit{client}, num modelo mestre-escravo. A fim de evitar condições de corrida e o \textit{overhead} de comunicação entre os processos, a ferramenta trabalha por meio de distribuição e troca de mensagens (MPI) ao invés do compartilhamento de memória. Assim sendo, os dados são copiados para cada \textit{worker} e ao final do processamento, agregados novamente no \textit{client}. A tabela \ref{tab:partool} contém a descrição das funções utilizadas da \textit{parallel toolbox}.


\begin{table}[!ht]   
	\centering
	\begin{tabular}{|l|p{10cm}|}  
		\hline
		\textbf{Função} 
		& \textbf{Descrição} 
		\\  
		\hline
		\textbf{gcp} 
		& \textit{Get current parallel pool} retorna as informações sobre os \textit{workers} ativos.
		\\
		\hline
		\textbf{parpool}  
		& Cria uma nova \textit{parallel pool}, ou seja, um conjunto de \textit{workers} e os demais processos necessários para o funcionamento da \textit{toolbox}.
		\\
		\hline		
		\textbf{parfor} 
		& Executa as iterações de um \textit{loop} em \textit{workers}. Para que isso seja possível as iterações devem ser independentes entre si e as estruturas de dados (coleções) utilizadas devem ter a característica de serem ``fatiadas''.  Por exemplo, uma matriz bidimensional pode ser fatiada de $2$ formas, pelas linhas ou pelas colunas.
		\\
		\hline		 
		\textbf{spmd} 
		& A função \textit{single program, multiple data} executando o mesmo código em diferentes \textit{workers}. Diferente do \textit{parfor}, os dados não precisam necessariamente estar particionados, visto que o \textit{spmd} permite a comunicação entre os \textit{workers}.
		\\
		\hline		
		\textbf{codistributed} 
		& Cria uma coleção que é distribuída entre os \textit{workers} e não copiada integralmente.
		\\
		\hline		 
		\textbf{getLocalPart} 
		& Obtém os dados de uma determinada partição de uma coleção distribuída.
		\\
		\hline	
		\textbf{codistributor}
		& Função que realiza a distribuição de uma coleção. Diferente da distribuição limitada que ocorre no \textit{parfor}, essa função possibilita que a distribuição seja feita de diferentes formas em uma coleção. 
		\\
		\hline
		\textbf{gather}
		& Função que realiza a agregação de uma coleção distribuída.
		\\
		\hline
		\textbf{drange}  
		& Executa um \textit{loop} entre as partições de uma coleção. Este bloco de código faz com que os \textit{workers} trabalhem simultaneamente em cada distribuição da coleção, mas impede a comunicação entre eles.
		\\
		\hline	
	\end{tabular}
	\caption{Descrição das funções utilizadas na paralelização do EbE-FEM}
	\label{tab:partool}
\end{table}

Para que a paralelização do código ocorra por meio das funções \textit{parfor} e \textit{spmd} é necessário que a estrutura de dados da coloração seja modificada, a fim de que possa ser ``fatiada'' e distribuída entre os \textit{workers}. Como pode ser visto nos algoritmos de \ref{alg:ebeCorCG1} a \ref{alg:ebeCorCG3}, as variáveis globais são indexadas pela variável $map$, que contém a lista dos identificadores de cada nó do elemento, como por exemplo $\{25 \ 12 \ 96\}$. Como estes índices não são contíguos, ocorre um erro durante a compilação do \textit{parfor} e o \textit{overhead} de comunicação no \textit{spmd}. Esta restrição do \matlab demanda uma nova adaptação da estrutura de dados e impede que a atribuição às variáveis globais seja feita de forma paralela.

A nova estrutura de dados gerada durante a coloração já retorna o vetor $b$ (ou $rhs$) completo, dessa forma, não há a necessidade do processo de montagem à partir dos vetores elementares, como descrito nos algoritmos \ref{alg:ebeCG3} e \ref{alg:ebeCorCG3}. Além dessa melhoria, o objeto retornado da coloração possui para cada cor, as matrizes elementares e o vetor $rhs$ referente aos elementos da cor. Em resumo, a nova abordagem retorna os próprios objetos que serão utilizados na paralelização ao invés do seu ``endereço'' na malha. Os pseudocódigos \ref{alg:ebeParCG1} e \ref{alg:ebeSpmdCG1} mostram a aplicação das funções \textit{parfor} e \textit{spmd} no algoritmo \ref{alg:ebeCorCG1}. A mesma adaptação é feita para o algoritmo \ref{alg:ebeCorCG2}.



\begin{algorithm}	
	\caption{\label{alg:ebeParCG1}Aplicação do \textit{parfor} no algoritmo \ref{alg:ebeCorCG1}} 
	\begin{algorithmic}[1]
		\For{c = 1,2...$|cores|$}
		\State{$matElCor = cores(c).matEl$}
		\State{$rhsCor = cores(c).rhs$}		
		\State{$R = reshape(r(rhsCor),3,[ \ ])$}
		\State{\textbf{PARFOR}}	
		\For{j = 1,2...$|cores(c)|$}
		\State{$M_e = precond(matElCor(j))$}
		\State{$Z = M_eR(j)$}
		\EndFor
		\State{\textbf{END PARFOR}}
		\State{$z(rhsCor) = z(rhsCor) + reshape(Z,1,[ \ ])$}
		\EndFor
	\end{algorithmic}
\end{algorithm}

\begin{algorithm}	
	\caption{\label{alg:ebeSpmdCG1}Aplicação do \textit{spmd} no algoritmo. \ref{alg:ebeCorCG1}} 
	\begin{algorithmic}[1]
		\For{c = 1,2...$|cores|$}
		\State{$matElCor = cores(c).matEl$}
		\State{$rhsCor = cores(c).rhs$}		
		\State{$R = reshape(r(rhsCor),3,[ \ ])$}
		\State{\textbf{SPMD}}
		\State{$codMat = codistributor(formaDistMat)$}
		\State{$MatDist=codistributed(matElCor,codMat)$}	
		\State{$codR = codistributor(formaDistR)$}
		\State{$RDist = codistributed(R,codR)$}

		\State{$MatPart = getLocalPart(MatDist)$}
		\State{$RPart = getLocalPart(RDist)$}
		\For{j = 1,2...$qtdWorkers$}
		\For{k = 1,2...$|cores(c)|$}
		\State{$M_e = precond(MatPart(j,k))$}
		\State{$Z = M_eRPart(j,k)$}
		\EndFor
		\EndFor
		\State{\textbf{END SPMD}}
		\State{$z(rhsCor) = z(rhsCor) + reshape(Z,1,[ \ ])$}
		\EndFor
	\end{algorithmic}
\end{algorithm}

Enquanto a paralelização por \textit{parfor} é feita elemento a elemento, a função \textit{spmd} distribui o processamento em $q$ partes, sendo $q$ a quantidade de \textit{workers}. Cada \textit{worker} executa sequencialmente a parcela do problema que lhe é atribuída. Conforme a recomendação da documentação, para se obter melhor desempenho, a quantidade de \textit{workers} deve ser a mesma de núcleos físicos do processador. Ao se utilizar o bloco $for-drange$ na linha $13$ ao invés do $for$ convencional, o comportamento do $spdm$ passa a ser equivalente ao do $parfor$.


\section{Resultados preliminares}
A ferramenta \textit{pdetool} forneça a opção de refinamento da malha, que consiste na subdivisão dos triângulos já existentes, no entanto, o refinamento da malha do objeto gerada pela função generateMesh é feito de forma diferente, por meio da alteração do parâmetro \textit{Hmax} que estabelece o tamanho máximo de cada aresta. A vantagem dessa abordagem é o maior controle das propriedades da malha, como por exemplo a quantidade de elementos, no entanto, a desvantagem é que a cada alteração neste parâmetro uma nova malha é gerada, em diferentes pontos. Dessa forma, não se pode precisar com exatidão do valor em cada um dos pontos de referência apresentados nas figuras \ref{fig:solPde}{(c)} e \ref{fig:solPde}{(d)}, no entanto, a corretude da aproximação pode ser verificada na média pelos nós que estão entorno de cada ponto de referência ou ainda considerando o valor do nó mais próximo. A figura \ref{fig:vizinha} destaca os nós da vizinhança de cada ponto de referência. Foram adotadas regiões quadradas de lado igual a $3mm$, $5mm$ e $10mm$, de acordo com a localização do ponto de referencia.

\iffalse
\begin{figure}%
	\centering	
	\subfloat[Refinamento com $Hmax = 0.6$]{{\includegraphics[scale=0.5]{figuras/viz0_6.pdf} }}%
	\qquad
	\subfloat[Refinamento com $Hmax = 0.2$]{{\includegraphics[scale=0.5]{figuras/viz0_2.pdf} }}%
	\caption{Vizinhança dos pontos de referência}%
	\label{fig:vizinha}%
\end{figure}
\fi








% ----------------------------------------------------------
% ELEMENTOS PÓS-TEXTUAIS
% ----------------------------------------------------------
\postextual
% ----------------------------------------------------------

% ----------------------------------------------------------
% Referências bibliográficas
% ----------------------------------------------------------
\bibliography{abntex2-modelo-references}
%\bibliography{bibfile}

% ---
% Inicia os apêndices
% ---
\iffalse
\begin{apendicesenv}
\label{chap:apendices}

% Imprime uma página indicando o início dos apêndices
\partapendices

% ---
\chapter{Tabelas do primeiro teste}
apendice

% ---


\end{apendicesenv}
% ---
\fi
\end{document}
